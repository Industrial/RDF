// Generated by LiveScript 1.3.1
var idServer, dnode, path, async, n3, preludeLs, stream, raptor, config, acceptType, contentType, each, log, debug, ExpressServer;
idServer = require('id-server');
dnode = require('dnode');
path = require('path');
async = require('async');
n3 = require('n3');
preludeLs = require('prelude-ls');
stream = require('stream');
raptor = require("node_raptor");
config = require("../../config");
acceptType = require("../../lib/http/server/middleware/accept-type");
contentType = require("../../lib/http/server/middleware/content-type");
each = preludeLs.each;
log = require("id-debug");
debug = log.debug;
ExpressServer = (function(superclass){
  var prototype = extend$((import$(ExpressServer, superclass).displayName = 'ExpressServer', ExpressServer), superclass).prototype, constructor = ExpressServer;
  function ExpressServer(options){
    ExpressServer.superclass.call(this, options);
    this.dnodeClient = void 8;
    this.dnodeRemote = void 8;
  }
  prototype._emptyDatabase = function(cb){
    var this$ = this;
    this.dnodeRemote.get({}, function(e, triples){
      if (e) {
        return cb(e);
      }
      async.each(triples, bind$(this$.dnodeRemote, 'del'), cb);
    });
  };
  prototype._importFixtures = function(cb){
    var serviceDescriptionFixtures;
    serviceDescriptionFixtures = require("../multilevel/fixtures/service-description");
    this.dnodeRemote.n3.put(serviceDescriptionFixtures, function(e){
      if (e) {
        return cb(e);
      }
      cb();
    });
  };
  prototype.start = function(){
    var this$ = this;
    debug("start");
    this.dnodeClient = dnode.connect(config.server.multilevel.levelgraphRpc.port);
    this.dnodeClient.on('remote', function(remote){
      this$.dnodeRemote = remote;
      this$._emptyDatabase(function(e){
        if (e) {
          return this$.emit('error', e);
        }
        this$._importFixtures(function(e){
          if (e) {
            return this$.emit('error', e);
          }
          this$.server.listen(this$.port, function(){
            this$.emit("start");
          });
        });
      });
    });
    this;
  };
  prototype.requireRoute = function(p){
    return require(path.resolve(__dirname, p)).bind(this);
  };
  prototype.routes = function(options){
    this.app.use(contentType);
    this.app.use(acceptType);
    this.app.get("/query", this.requireRoute("./server/routes/get-query"));
    this.app.get("/api/rdf/2015/01/query", this.requireRoute("./server/routes/api/rdf/2015/01/get-query"));
    this.app.get("/api/rdf/2015/01/sparql", this.requireRoute("./server/routes/api/rdf/2015/01/get-sparql"));
    this;
  };
  return ExpressServer;
}(idServer.http.express.ExpressServer));
module.exports = ExpressServer;
/*
  formats:
    # TODO: Learn how to decide the input language filter.
    input:
      # TODO: Get the appropriate types
      \grddl: !->
      \guess: !->
      \json: !->
      \ntriples: !->
      \rdfa: !->
      \rdfxml: !->
      \rss-tag-soup: !->
      \trig: !->
      \turtle: !->

    # TODO: Decide the output language filter based on the HTTP Accept header
    #       on the request.
    output:
      # TODO: What to return in case of HTML? A table of triples?
      \text/html: (req, res, next) !->

      # TODO: How to decide between XML forms?
      \application/xml: (req, res, next) !->
      #\atom: (req, res, next) !->
      #\rdfxml: !->
      #\rdfxml-abbrev: !->
      #\rdfxml-xmp: !->
      #\rss-1.0: !->

      # TODO: How to decide between JSON forms?
      \application/json: (req, res, next) !->
      #\json: !->
      #\json-triples: !->

      # TODO: Get the appropriate types
      \nquads: !->
      \ntriples: !->
      \turtle: !->
      \dot: !->
*/
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}